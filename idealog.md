啊，我有一个让AI来通过AI来驱动项目管理的一个想法，啊，请你从呃请你作为架构师或者项目管理，项目管理专家这个角度来帮我分析一下这个想法，初步的想法是这样的呃，就是首先我要建立一个项目信息库，然后这个项目信息库啊，对项目信息库的组织方式是就只有一个文件，这个是方便AI去看，然后呢这个文件的内容是越重要的放在最上面，然后也不重要的放在下面，然后下面你的内容要跟上面的内容来对齐。就是下面的内容要给上面的内容对齐，就是有这样的一个要求，然后这个信息库是怎么维护的呢？是通过这样的一个机制，就是我会呃让AI让AI那个嗯，让AI来从三个维度来问问题。来来提出他的想法，第一个维度是呃消除疑问，第二个维度是就是呃从疑问这个维度，就是对新对这个项目现状的这个呃哪里不清楚？然后第二个维度是问题，这个维度就是觉得现状上，现状上哪有不好的，然后第三个维度是这个呃是这个提升项目提升就是怎么让现状变得更好？得从这三个维度去提问题，提出提出想法。然后他提出了想法之后，然后会如果是疑问的话。然后可以去看这个代码去解决，然后也可以去通过我来解决，然后如果是问题的话，然后就由我来判断是不是他提的这个是不是一个真正的问题，然后这个问题的优先级怎么样啊，如果是提升项的话，也是会我给出一个判断。然后就通过这种方式来驱动，呃，驱动项目的开发。然后这个，然后这每一项解决之后，都会再反过来更新这个信息库，更新这个文档。对，然后觉得这里面这个这个想法能不能越想运转的起来

然后进一步的一个想法是就是这个信息库里面呃都要保存哪些信息，然后我现在的想法是呃就是有一个想法是就这个信息库是独立于这个项目，独立于这个项目，就这个项目就是是一个给他的项目是然后这个项目呢？然后这个项目呢，它是没有这个信息库，也能够也是完整的。没有这个信息库也是完整的，所以这个信息库里面就不会包括像这个像API的定义或产品原型的定义这样的信息。因为这些是项目本身就应该有的信息。对，这是项目本身就应该有的信息，然后呃这里面呢就记录对于这个信息的这个原信息的描述，就是这个比如说这个产品原型的文档在哪，然后他是通过什么样的格式定义的，然后就应该怎么样的去怎么样去看，对，就是这样记录这些文源信息。你觉得从这个维度去区分，或者从这个呃是否有可执行性，可行性，然后是否能够达到我说的我想要的这种效果

嗯，我想以这个项目的d来作为驱动，然后这个项目的信息库独立于这个项目之外啊，也可以放在里面，但是放在可以放到这个ignore里面，就是不参与，不进啊，一般也可以进去，那需要另外设计一种机制，就是呃，这个原信息库里面记录记录。呃，他这个信息更新的到哪个bit commit了的记录，他更更新到哪个bit commit了，然后然后这个然后下次呢，就他那个看这个原型库是否还有效，就看这个他记录的这个bit是不是跟那个bit仓库是不是同步的，如果是同步的，那就说明啊，这个还是有效的。然后如果不同步的话就要触发这个一次同步，然后这同步的话就是拿这个他不不了解的这几次it can make的内容去同步到这个信息库里面就好了。然后对于这个对，所以它更新了之后，然后因为它要根据上这个geekmit来做更新，所以它更新了之后自己不能提交，所以就是它可能不太适合放到这个geek里面去管理。对，所以对，然后那个然后就需要beat。对，大概就是这样

啊，对，影子分支这个想法非常好，这个我没想到非常棒，然后另一个是另一个我的想法是需要呃给这个就是呃建立这个刚才说的那个决策日志，我觉得确实是有必要的，是非常重要的信息，但是这个信息呃，这个信息怎么来产生其实是一个问题，然后呃其实我觉得有一个信息跟他是类似的，然后可能是通过在我们这个框架下面是比较容易去收集的就是这个问题呃的问题这块，因为每遇到一个问题，然后我们都要有决策。他要有一个记录就是呃疑问的话，其实这种还好，疑问的话只是啊只是消除不清晰，然后就对于问题这种就是可能其实就是涉及到这个对于问题的判断和决策，然后我们需要把这个记录下来，然后还有promotion这块就是promotion这块，然后把这个也记录下来，其实这个我理解就是决策日志了就是决策日志了。，就是决策日志了。然后对，然后另外呃，因为我们记录这些呃就是要记录加一种信息，就是记录这个问题和解决的结果，解决的结果。然后呃记录了这些信息之后，然后可以入的一个功能是呃呃，比如说这个我们这个dia系统，他给我提了一个问题，然后或者提了一个promotion的呃建议，然后我可能给他的回复是你你想歪了。就是这个问题，你这个问题不重要，就是然后就这个或者说这不是一个问题，然后或者是提升提升的这块呢，就是说啊这个方向不太对，然后或者说就是然后觉得这个或者就给一些这个其他的解决的方案，然后把这些记录下来，然后这些数据呢其实从某种程度上可以用来用来提升它这个整个的这个DNA系统，就是他的他提问题的能力就是哪些问题，呃，是呃呃该提的哪些问题可能就是提提的不太不太对，然后我就可以用了这个优化这个就这个提问题的这个它的提示词。对，然后同时也作为这个决策日志的一部分。就是相当于作为决策日志了。然后这样的话感觉整个流程是能够串的起来，然后嗯同时有可能能够自迭代

我想这个系统能不能先用claude code这种。嗯，让他转起来。就是比如说把提问这个当成一个做成一个skill，做成一个claude code里面的skill，然后对，然后把从代码同步也做成一个skill。对，然后那整个的流程可能就是呃，就是那个嗯，就是运行一下这个呃这个提问的这个skill，然后让他提出问题，然后呢啊对对，还要再加一个解决问题的skill，然后这个可能有一些疑问可以从代码库里面直接去解决，然后这个就不用我去回答了，然后再加一个这个解决问题的skill，然后就是这个提出问题的不断的提问，然后解决问题的啊就是如果是疑问的话，他就解决，然后直到没有疑问，然后没有疑问了之后呢，然后他就可以提升提出这个问这个问题和改进项目，然后提出这些之后呢就有需要由我来介入。就下由我来介入，然后对，要有我来介入，然后这个介入就然后来如是问题的确实是是问题，然后就产生了一个产生了一个代办，然后如果不是觉得不是问题的，那可能这个就做在就只是在做一个记录，这个用了，后面用他让他用这个来做迭代啊，如果是这个提升，对于提升下的话，如果觉得是应该提升的下，然后就产生一个代办，对，也产生一个代办，对，就是就这样。就这样，嗯，对，然后对然后这个代办的话，就其实可能就是开发工作或者是啊调研的工作或者是一些延迟决策的事情，对延迟有一些对，有一些决策可能现在比如说提出了疑问，他现在可能做不了，就是说这个以后再说，然后这个可能就是延迟决策，对，有这种情况，然后就产生了这些代办，然后呢就可以然后再有一个AI agent代码，代码agent，然后来消除这个来处理这些代办，处理这些代办，然后就然后就整个系统就能转起来，然后他每次提交代码之后都要做一次那个commit更新COMMIT，然后这个commit之后，然后从这个信息同步的这个，对，这还要加一个从代码库向这个原信息库同步信息的一个skill，然后这个skill就是比较这个更新他ID，然后这个更新这个信息库。对然后就这样的话，是不是就可以把这个流程转转的啊对对，把这个流程转起来，然后这里面我有一个疑问的地方是比如说我用claude code的这种嗯编程agent，然后在里面构建这样的流程，呃，应该怎么来构建？然后那个code还有本身有自己的这个上下文系统，有那个session记忆。对，每个session有自己的记忆，然后还有这个全局的这个claude.md这种全局的上下文，然后就是跟我的这个系统跟他的这种有没有冲突，跟他的本身的这种上下文系统有没有冲突，然后如果用claude code这种应该怎么来用呢？


总体说明：

DNA系统中的角色，每个角色都是一个工具或者说应用，具体是一个ClaudeCode中的Skill。 
User Input Processor， # 处理用户主动为项目提供的信息， 做记录并更新DNA文件。
Repo Syncer， # 将Repository的更新，同步到DNA文件。
Questioner， # 提出疑问，
Issuer， # 提出问题
Suggester， # 提出改进建议
Question Solver， # 解决疑问
Coder， # 写代码解决Issue/Suggestion
Reviewer， # 验收修改
Self-Improver， # 自我提升


几个流程：
1. 用户主动提供信息，更新信息库
Step1: User Input Processor 工作，用户输入元信息。

2. 元信息库维护的流程，目标是确保信息库可用。
Step1: Repo Syncer，同步Repository。
Step2: Questioner，提出疑问
Step3: Question Solver，解决疑问
再回到 Questioner，直到没有疑问，再进入下一个步骤。

3. 创建ISSUE的流程。
Step1: Issuer，提出问题 （先判断信息库的CommitID与Repo的CommitID是否一致，不一致则更新信息库提示用户，一致则提出问题）
Step2: 用户分类Issue

4. 创建SUGGESTION的流程。
Step1: Suggester，提出改进建议（先判断信息库的CommitID与Repo的CommitID是否一致，不一致则更新信息库提示用户，一致则提出问题）
Step2: 用户分类SUGGESTION

5. 解决ISSUE/SUGGESTION的流程。
Step1: 读取指定的ISSUE或者SUGGESTION文件。
Step2: Coder工作，解决Issue/Suggestion（创建一个新的分支，进行修改，提交修改）
Step3: Reviewer工作，验收修改。如果修改通过，就合并到主分支，如果修改不通过，就返回给Coder，Coder进行修改，直到修改通过。

6. 自我提升流程。
Step1: Self-Improver工作，根据用户对于Issue/Suggestion的反馈结果（比如哪些Issue提得好， 哪些Issue提得不好，哪些Suggestion提得好，哪些Suggestion提得不好），针对性优化Issuer和Suggester。

从架构视角来看这个流程是否能转起来，有什么风险点，如何能快速落地


关于那个就是原信息的组织。然后前面想到了一个是就是上层的下层的依赖，然后统跟上层的相统一，然后这是一个，然后还有一个是对，就是那个上层的在前面，然后然后最重要的在前面，然后细节的在后面。对，然后另外的一点就是那个不是不是不取代项目本身的这个信息，然后而如果项目里项目里面已经有的，就是一些细节的，就是引用项目里面的。对，就是不存特别细节的，不会对项目库里面的信息做大面积的冗余。然后然后然后还有一个想法是，就是关于这个信息库的这个指导原则，我觉得现在这个还是太泛了，然后嗯我想信息库里面应该有从一个呃视角来分的话，就是要有这个意图信息，然后其实这个是用户给定的，对，主要是用户给定的比如说用户，用户相当于是用户的一些一些指导性的意见，然后还有这个还有这个状态信息，就是这个新项目当前是什么样的现状，对，有专项目的现状，一个是这个用户的意图，然后然后这个信息库里面的原信息库里面的这个信息，呃，应该都要有这个来源，都要有来源，比如说啊，有些信息，有些意图信息，是这个或者说或者说这个意图信息，其实应该只能是由呃，有这个用户确认确认过的，要么是用户输入的，要么是就是呃AI给的建议，然后用户呃确认的。的意图信息，然后还有对，一个是从意图和呃现实情况的这么一个角度的划分，然后呃另外一点是这个就是信息要有来源，也就是需要在信息库里面标明这个是呃，用户指定的，来源于用户或者来源于AI的就是AI的总结啊，还是，呃，对，还是这个项，来来自于对项目里面的啊引用。对，然后这是一个角度，然后这就这是两个两方面的原则，然后另外考虑的话是怎么来怎么来那个指导就是应该包包含哪些内容？就前面这些都非常的呃非常的这个高屋建瓴的原则，然后具体包含就是相对来说更具体的指导，然后这些我的一个有一个想法是嗯，首先首先那个，首先就是比如说那个消除疑问的这个这个agent，然后他他怎么样了？有一些因为我不想做成那个按项目，按某种类型的项目去做指定的这样的做模板这种的形式，然后希望有一个通用的原则，你得有一个有一点就是首先他得搞清楚这个是做的。就是这是一个，或者说这个，就他的第一个疑问点就是得是这个。就是我们现在这个原信息库描述的是一个什么事儿？





第一个切面，文件内容构建组织原则：
1. 重要的在前，不重要的在后
2. 总结的在前，细节的在后
3. 设计在前，实现在后
4. 后面的内容，要与前面的内容Align
第二个切面，意图与现实
1. 用户意图驱动，用户意图是最高指导，需要谨慎对待
2. 在同一个问题上，用户新的意图覆盖旧的意图
3. 不同的问题上如果意图有冲突，需要与用户确认
4. 现实就是Repo的现状
第三个切面，直观、宏观、微观的要求
1. 直观层面，要让人直观的知道这是一个什么事
2. 宏观层面，要让人通过看这个文件有一个完整的信息结构
3. 微观层面，不存储细节信息，要做到知道信息去哪儿找，是以什么形式存在的，如何获取
第四个切面，来源和可追溯性
1. 所有信息必须标明来源，要么来自于对于用户输入的抽取和理解，要注明是用户的哪条输入（引用用户输入记录的编号），要么来自于对于Repo内容的总结（引用具体的来源）。
2. 不得有任何编造和推断的信息。

我想把上面的这些原则做为整个信息在创建、维护以及去提出问题和改进的指导性原则。
从信息科学家的角度来看，这样的要求是否是完备且自洽的？ 有没有冗余？  从工程实践角度来看，这样的一些要求是否具有可行性？有什么进一步的拓展和改进的想法




第一个切面，意图与现实
0. 元信息主要是清楚的体现用户意图与现实状态。
1. 用户意图驱动，用户意图是最高指导，需要谨慎对待，用户意图可以包括正向和负向意图。
2. 在同一个问题上，用户新的意图覆盖旧的意图
3. 不同的问题上如果意图有冲突，需要与用户确认
4. 用户意图可以来自于用户的输入、用户对于各种问题的反馈。
5. 不得从Repo中直接推断用户意图，但是可以提取之后向用户确认。
6. 现实状态要从Repo中去提取。
7. 用户也会提供一些外部的状态信息。
第二个切面，直观、宏观、微观
0. 元信息的目的就是把这个事情描述清楚，把一个事情描述清楚的方式是先直观，再宏观，再微观
1. 直观层面，要让人直观的知道这是一个什么事
2. 宏观层面，要让人过看之后有一个完整的信息结构
3. 微观层面，不存储细节信息，要做到知道信息去哪儿找，是以什么形式存在的，如何获取
第三个切面，来源和可追溯性
1. 所有信息必须标明来源，要么来自于对于用户输入的抽取和理解，要注明是用户的哪条输入（引用用户输入记录的编号），要么来自于对于Repo内容的总结（引用具体的来源）。
2. 不得有任何编造和推断的信息。

这样修改之后如何



1. 用户意图的自我冲突。
2. 当前已经实现的部分与用户意图的冲突。（不管用户意图中没有实现的部分）
3. 项目现状中本身存在的问题，可以是结构性的，也可以是细节上的
4. 缺失重要信息，让人无法通过META了解项目
5. 验证失败，如果条件具备，参照信息中提供的方式进行测试验证，与预期结果不一致。

我想可以从以上几个方面来找Issue，从信息和工程专家的角度来看，有什么问题和补充


我有一个想法，就是前面我我是定义了一系列的原子的命令，比如think，比如tell啊，比如code，如review。对，还有audit propose。那我觉得是不是可以有这样的体验，就是用户输入lm，然后就进入了一个嗯，像cloud code这一样这样，然后进入了一个啊intext inactive的一个进入一个interactive的一个环，一个交互式命令行的一个空间，然后它在这里面可以，呃，就是输入输入一些命令。有时候i think输入这个我太或者说他默认的这个行为就是，嗯在这上在这里面默认，如果发一个指令就是说一段话，然后默认其实就是tell。这样跟cloud code现在的一些主流的命令行编程的这个工具就使用，使用上就比较接近。然后整个流程里面。嗯，有一些点是我有一些点是在这个里面，我可以自己存一些session的信息，比如用户是刚这个think完还是刚做了，然后就是有一些流程可能，嗯，是不对的，然后就是可以阻止用户，啊，在什么情况下不能做什么事情，这样然后有一些，呃，能并行的或者能可以放在比如说前面说的那种静默的什么一些操作，可以放在后台。然后用户然后可以继续，就是能同步做的，可以让他同步在前台继续做。这样的一种体验，嗯。是不是也是一种方向？然后另外的话，我这还有一个想法是我希望整个过程是不是可以，比如说Autopilot，Autopilot是不是可以，是不是可以自动驾驶？对，是不是可以对outpinite自动驾驶，然后如果是自动驾驶的话，可能比如启动lm什么，然后这时候他就就变成就是用户。嗯或者说我们在选项里面加一个就是加一个out，out的命令。加一个auto命令，auto然后这个auto命令了就会嗯，开始自动的做一些事情，比如他然后先那个先同步，先同步信息，然后更新原数据，更新原数据之后，然后就自动看这个原数据，现在是不是已经足够清晰可用。通过question和resolve的这个机制。然后由原数据这个清晰可用了，没有问题了，然后呢就呃他可以再通过这个issue issue和这个propose的这种机智。然后来给自己找找事儿干。然后找到事儿干了，就再用这个cloud code啊，还是啊，还是什么其他的然后解决这些问题。然后就他也可以自己去谈一些事情的优先级，然后解决这些问题。然后然后解决之后，然后就开始在啊比如在review你也可以在自动review review,然后看跟这个用户的想法是不是对齐，然后中间如果中间如果需要用户介入的，然后就停下来让用户介入，但是这种介入呃就是变成呃变成AI驱动，就是它是变成向下属向上级汇报一样，然后现在嗯我知道你要做什么了，然后那我给你几个方案就汇报一下我的想法，我的工作方向，然后以及说这个。呃，就是比如说我提了几个issue，然后你觉得这个是不是issue？我提了几个suggestion，然后你觉得这个是不是合理的？这个是不是好想法？然后就人这个就半自动驾驶，然后人就变成了一个只需要就变成了被动，就变成选择，就不像就省去了一些细节的思考，然后变成了就是拍板的角色。对，变成拍板的这种角色。然后就当中间也可以说这个打断他，然后打断他，说给他打断他，然后说给他一些嗯输入，比如说觉得他方向偏了，或者这个嗯怎么样，就变成了这种。嗯，对，练成这种监督情况下的半自动驾驶，然后如果觉得这个项目已经进入正轨了，然后甚至可以说啊全自动驾驶让他让他完全这个AI完全主导这个项目，然后就定期看一下进度就行了，然后大不了就如果出现偏差就回滚回滚一下，然后再再继续。就是目标就是嗯要希望能够烧掉大量的token，然后因为能够烧掉大量的token，就代表有可能能够创造大量的价值。然后这就是，呃，就是应该就是给给用户一个方式。就自动烧掉大量token的一个方法


我还有一个，我还有一个产品是在手机上。在手机上给在电脑上运行的软件去发消息的一个产品，我希望后面这两个产品能够打通就变成了啊就是m然后在电脑上运行，如果需要确认的地方或者他定期汇报进度，然后就是我可以在手机上跟他交互。然后我可以在任何地方就是做一些点点，或者比如说做一个选择，做一个点击，然后就能够完成开发任务，然后晚上的话可以让它自动运行，可以让它自动运行，就是去做一些事情。这样就可以。对，这样就变成了一个确实就可以变成一个人拿着手机指挥，一个一个就是这些指挥好几个开发团队在做事情，因为可以让可以同时推荐不同的项目。对啊，这是我希望我后面的一个产品的闭环的，嗯，一个思考，一个考虑


关于这个。用户输入的都有可能是什么呢？就是一般来说，然后我想到可能有三个点，一个是就是用户的尾端输入里面，一个有可能是啊，有可能能拆解出一些他的意图和决策，然后这些信息的话要进入这个，呃，进入这个项目的元数据里面。然后第二个点是有可能拆出一些，有可能有一些是临时的想法，就是没想好的东西，然后就需要记录一下。我觉得这个可能也是常见的，就是用户并不一定是说了就是想好比如说想到这一点嗯然后还有一点是，因为如果把他说的什么都当成是他的强意图的话，那他用这个时候可能有时候就就不敢说话了，不敢乱说话了。有一种有一种高处不胜寒的感觉。对，有可能有些是临时的想法，这个我们也要更如何处理呢，如果把它把它拆，可能需要把它拆解出来，然后怎么样去做什么方式处理一下，可是还有一些是还有一些是就是任务他需要就是有一些事儿要做，然后觉得对，就是就相当于是记了一个代办，他记了一个代办一个待办事项，然后一般是像这种呢就需要可能寄到这个。寄到这个代办里面要要有一个可能有一个鸡蛋，鸡蛋蛋的一个地方。比如说用户提了一个探索的方向，然后就是他可能听谁说了这么一个方向，但是没想好，然后就像或者探索什么之类的。就这种信息可能不太适合放到吧。我不确定啊，现在不太适合放到就整个的原数据这里面


我觉得这个系统最重要的，我现在的一个思考是主要还是一个AI as me这样的一个想法，然后怎么样来实现AI as me？其实还是要对于这个用户的想法有更深入的研究，就是就尽可能的高效的去收集他的想法。然后这样才能做到AI as me。AI爱你。然后我想从什么样的就是一些比如说确定性和不确定性这样的维度来划分一下这个用户的想法，比如什么样的想法是成熟的，什么是不成熟的。就是这个我觉得就是人是有一个思考的过程嘛，然后就是人的想法肯定也是这样的，就是有些是呃就是已经形成非常稳固的结论，然后有些是可能还在一个初步的一个想法的阶段，然后这个系统可能另外需要去关注的一点就是怎么样让他的帮助他记录这些成熟的不成熟的，或者说怎么样来让他来帮他来演进他的想法。对，就是变成一个他的思维的一个数字半生嗯，我们现在的这个记录的话，这个想这个做法可能还是不够不够，不够好，就是现在只是把他的想法当成一个意图来处理，当成意图来处理，然后这种意图这种意图就是每个他的想法都当成一个起来，就是现在就有点太非黑即白了，就是没有办法去区分哪些是他现在稳固的想法，哪些是他这个现在的一个初步的一个灵光一线的想法。这个。 然后关于这一点，从信息论和心理学的角度，你有什么样能够给我提供的线索和信息吗？


啊，我现在有一个想法是这样。就是在原数据里面，呃，把意图的数据和现实的数据分开。呃，就是把他们彻底呃变成就变成两个文件，一个是intent，一个是reality。然后呢intent这里面包含两部分数据一个是用户的输入，用户的原始输入和用户的各种行为的各种反馈的记录。另一个呢是呃，就是根据用户的这些所有的输入，然后做出来的这一个他的一个意图。他的一个意图总结。然后关于reality这部分呢，也有两部分数据，就是啊，这这里面只有一部分，因为那个repo其实不属于原数据。然后就是用repo，一部分是就是repo是一部分，然后就就是我们如果除去repo的话，就是有一个repo的一个总结。这就是reality这部分的数据。嗯，然后呢整个系统也跟前面的思路也接近，但是有不一样的地方就是这里面把这个，这里面就变成了一个嗯，就核心就变成了这个意图管理，或者说那我们整个系统的一个核心可以叫意图驱动开发，比如叫intent drive的development对，就变成叫d。然后呢，关于这个intent的管理，呃，有一个思路，有一个想法是就是前面你给我的那个输入很重要，就是intent，其实重要的是重要的是减伤。他对他的管理重要的是减伤。就是让他的伤去减少。然后怎么减伤呢？就是intent对于一个已经存在的repo，那最开始这个intent的数据，因为intent其实也是需要输入的，那这个intent最开始是没有的，那这时候就需要其实就需要去模型就是AI。利用repo的数据，或者利用repo提取出来的这种数据去推断。去推断这个intent。推断intent，然后intent，那这种推断的intent呢？这是因为这个知信度很比较相对来说没那么高，所以这个呢其实就是可以认为是高伤的，伤比较高，然后呢然后然后就通过去，然后我们提供一个比如说叫叫叫dig，dig这种工具。啊，对，叫这个这种工具，然后嗯它是用来减伤的。就用来明确意图的，比如说就是用户可以随时查看我们给他抽象出来的，他总结出来的他当前的意图，然后如果他觉得哪有问题，他可以去针对有问题的点提出修改，然后这是他管理的一种管理意图的一种就是方式。就是我们帮他汇总总结，然后他可以随时查看去修改。然后另外有一种操作，刚才说的那个dig这种操作呢，就是嗯如果用户执行了这个，然后就给他一个就是从他的这个他的现在的这个intent里面。呃，我们给他找出，就是他现状里面找出这个那个商增，找出这个商商减最大的。删减最大的这个问题。然后就是负伤增最大的这种问题去留给他，然后让他去看看他有没有更明确的那个说法，然后就通过这种这种方式，就是每次如果他通过用我们的这个这个工具，就每次都给他这个负熵增最大的问题，就这个负熵增是通过AI来判断的。他觉得哪个问题是就是当前是那个收益最高的，然后就去问哪个。对，这是给他提供的一个呃意图管理的一个工具。嗯，对，相当于意图呢就有。啊，可以从repo里面去推断，然后呢可以用户可以呃给给一些输入，然后我们从用户的各种行为里面呢去都去抽取然后呢，这样抽取出来的这个意图呢，然后用户还可以再去就直接去修改调整，然后也可以用我们的第一个工具就是然后去这个去去去调整他的意图。就去完善去，我其实是我们帮助他完善他的意图。对，然后其他的方面就是跟其他流程跟之前聊的呃那个方案就差不多，就是意图出来最终还是为了指导开发。就是但是整个系统其实整个开发过程，整个开发过程其实呃就就把整个开发过程定义成一个商检的一个过程。比如说，啊，如果在这个用户的这个想法还不太确定的时候，然后这时候最重要的事情其实不是去写代码实现，而是去帮助用户去让他去确定完善自己的想法去明确方向。就是先把意图这个呃能够确定下来。能够就是有相对明确的，就是至少在某些方面相对明确，然后这些方面的就可以做了，然后有一些这个高商的这种意图呢，然后可以继续的去挖掘或者去继续的去帮他去继续的帮他去完善。对，然后就变成了就是这样的一个想法。啊，从请你帮我分析一下，从信息论，心理学和产品理论这方面，都给一些扩展和建议


然后这个就叫一个吧。然后这个ego他其实是呃他其实是所有的用户，就是用户从用户的所有给所有的行动数据和他的给的所有的输入里面去抽取出来的。然后这个过程就要哦，有一定的。逻辑和有一定的这个理论在里面，这个我现在是没有想清楚的，就是比如说现在用户有非常多的输入，啊，比如说他通过tell这种方式然后，啊告诉我们怎么怎么样，然后就是关于这个项目，如果他讲了很多，然后他讲的这些内容里面呢。就有可能是，就可能什么都有，比如说是他为什么做这个项目啊，他是啊看到了什么东西啊，还是听到了什么呃什么什么呀，听说了什么呀，还是自己遇到了我想解决自己的某些方面的问题呀，就是都有可能，然后他也有可能比如说，呃有一个初步的设想，然后要怎么怎么样，然后就说这个，然后有一些对于前景的展望和想象要怎么怎么样。对，就是他可能给了各种各样的输入非常多，然后就是他这种输入是一方面，然后比如说后面对他有可能也有可能，比如说像像我们这个系统问了问了什么问题，然后那就问了关于这个项目的什么问题啊，对吧，然后其实对于这种这种问题啊，某种程度上也反映了他所关心的这种切面或者侧面。然后比如说他在给我们提出了这个proposal或者提出了一些problem，提出了一些issue的时候，然后用户给的这个反馈，他可能觉得你提的是一个好问题。那代表其实就代表了用户的某些想法。有可能他觉得你这个问题我不关心，然后你想的太偏了，也代表了他的某种想法。对吧，这种其实都是可以去推断出一些东西来的所以就是怎么从这些，我们收集到的所有的用户给的。使用我们的系统的这个所有的数据里面去。去构建他的一个是一个是一个难点吧，然后当然他也可以主动，就是我们告诉他这个现在这个异构的成熟度不够，然后我们可以主动向他提问。就是通过我们的这种，帮他设计的这种提升异构成熟度的这种。提升ego成熟度的这种方式。其实他在这里面也会给一些反馈，就是本质上也是他给的反馈信息，但是这种可能更直接一点，然后对，用户也可以直接去，啊，查看当前我们给他这个给他设计的，给他总结出来的易购，然后去看里面。给他总结出来的ego，然后看里面有没有什么需要调整的，这也是一种嗯信息，然后就所有的这些信息其实最终都是要去塑造这个爱狗然后然后这个爱购呢，所以需要需要有一个塑造的。一种逻辑在里面。嗯，然后我的一个想法是首先把用户的所有的数据分分类，所有的比如说输入的数据。嗯，分分类。比如说比如说有用户说了一段话，里面可能有比如说可能有他的决定，就是这个通过AI的分析是我觉得是应该能分析出来的，有些是他的决定。然后呢有些呢是他的一个有一个期望或者是一个一种展望吧。然后呢，还有是他的，还有呢，是他的疑问，还有一些是他的疑问。然后还有一些呢是其实是他下达的任务，下达的任务。然后比如说还有一些呢，可能就是他的吐槽，甚至是吐槽抱怨。对，但这个其实这些都能代表他的一些态度和想法。对啊，就各种各样的，可能有各种各样的信息。我不知道，从信息这个维度来看，一个人。嗯，所能表达的这种信息可以分成多少类？就是相对来说比较能够去比较General的，不用去specific到一个特定的领域啊，我想先有这么一个基本的分类，然后呢再看是怎么样的去利用这些类别，然后就初步的分类的想法可能就是，比如说他提了问题。然后呢，啊，他他的一个他给了一个观点。然后呢，或者说他做了一个决定。或者说他下了一个禁令，就是明确禁止什么样的事情。然后或者呢就是他提了一个想法。提了一个想法。就是因为我想的我觉得这个不知道有没有什么能够比较好的这种完整的，就是一个比较自洽的这种划分类的方划分的方式，而且对于我们这个项目能有指导意义的


前面你提到的那个。数字伴生模型指的是什么？好像没有进一步的说明。然后然后你提到的那个分类是五类，为什么ego里面只有三种？三，三层的存储只有car style和horizon。嗯，总体来说这个分类给了我非常大的帮助。就是非常有收获。我觉得确实是非常可行的，然后就是想了解一下你，嗯，后面的那些为什么会跟这个分类有冲突？然后对，其实我这是这也是在做这种负伤增也是在减减伤。然后还有一点是就是从产品层面，从用户这个使用的角度，用户体验角度来看，嗯，假如说我们做了一个这样一个负熵增最大的一个一个东西就是一个体温器。那一个提问器，然后那用户接触到这种负伤增最大的提问，他的最大的感受会是什么样的？对，他整体上感觉会是什么样？是是这种有很高的这种决策强度吗？还是说感觉，啊，自己被打中了一个。就是被这个打中了自己最困惑的点。类似这种感觉吗？从他的心理体验上来说，嗯，然后另外的话就是怎么来找到负上增最大的这个这个问题，怎么怎么去？这个有什么样的思路吗？这个更多的是这个是心理就是心理学层面的，还是这个？信息学层面的


还有两个问题，第一个是就是前面把代码这部分叫reality。然后现在我觉得就代码仓库。代码仓库可以叫reality，但是对于代码仓库的这种修改，这种嗯，commit commit list这种其实可以视作是behavior。可以看作是behavior，然后确实，然后这种的话，可以认为是行为。就是有些，有些代码，比如说用户是用户自己写的，就不是通过我们的这个系统，通过他的我们的意图什么之类的之类的来触发的，是用户自己写的，其实他那他这也是一种，就这种是一种也是一种有比较高的这种信息量的数据，就是他看他做了什么。对，这是一点，但是如果是由我们的系统触发的这种提的这种issue啊。啊，或者什么，然后代码也可能但如果他有可能会中间过去审阅什么之类的，这种行为也会被记录倒也是然后还有一点是就是只有商增。那这个用户他的就是这个，我们这个爱狗它代表的是就是爱狗它有可能也有得有一个时间的一个概念，就是它比如说是就代表当下。比如说前面你说的这个例子。你说的这个例子，这个例子里面就是用户现在可能他用的udp然后还是铭文的，但是呃然后他的这个提的又是说这个要高性能又要安全，啊。但是那这样的话，其实有可能比如说他现在的实现就是一个就是一个MVP就是一个poc做了一个最简单的实现，然后但是他后面确实是想做到这个呃既丝滑又安全的。其实这种，啊，这种矛盾只能说是因为时间上的错位，或者是阶段上的错位导致的。可能等他这poc结束之后，然后接下来他就要追求这种，嗯，这种安全性啊，司法性啊之类的。丝滑性这这之类的所以这里面就有考量是这个ego它代表的是代表的是一个什么时间的一个状态，就是代表的这个时间维度上来看是什么样的，就是只代表当前。还是但是如果只代表当前的话，用户其实可能会提很多。未来的想法。对，会提很多未来的想法。只代表当前其实可能不太成立。就是给我的感觉。但是如果说代表了未来，那就是跟现在的一些冲突啊什么之类的。当然这种可以通过。就是增加在这个就是比如说刚才这个问题。AI我们向他提问，在dig的时候向他提问，说你现在有这样的冲突，是为什么？那他也可以说，因为我现在这个阶段是poc。对，现在这个是poc阶段，然后所以就先没考虑，不管这些。然后那我们在这个爱狗里面就记录了一下，就是当前的这个阶段是poc，然后嗯poc的时候，这个要求是要降低了，怎么怎么样。啊，对可能也是一种思路，但是就是从整个信息演变信息演变或者信息论这种层面，对于这种呃时间维度上的或者时间的概念，或者这种这种的话有什么样的？嗯，在这个维度上如何去去看待，或者如何去更好的去维护呢？


呃，另外有一个想法是呃，就是关于就是对于一个人的想法来说，对一个人的想法来说，其实呃应该可以，是不是可以这么定义，就是在什么时候想要什么。其实是呃就是每一个想法都可以，都可以，就每一个这个intent，呃都可以从这个角度去理解，就是什么时候想要什么，然后这里面其实就有一个时态的问题然后这个时态的话，比如说可以是always，然后可以是right now。然后有些可以是呃就是future。或者是对，future然后还可以是这个，呃，这个就是current当前想要的。对，这个是不是可以从这个维度去呃理解？然后可能还有这种表示，就是还还可以有这种表示程度的，就是另一个维度就是长度，是比如说是呃就是那个。Very嗯，就是比如说是Must或者never或者这种should。对，如果是不是可以从这几个维度，呃，就这两个维度来来定义一下人的这个呃intent，然后然后定义这些就是把所有的把一个人所有的想法按这方面去归类，就是他去归类，然后呢，然后汇总他所有的想法，然后推断目标是要推断出他当前，他当前想要什么。然后这是能知道，就他当前呃最想要的是什么，然后这个是能够指导他就接下来的行为
然后有些想法可能是叫anyhow，不管怎么样都要实现。对，然后对于这种想法的话，就可以放弃一些，就是放弃一些其他的原则啊之类的。
还有一些是比如说就是从时间层面有些是呃每天都想要的，或者说是就周期性的，或者是每周每周想要一个什么样的，就是一个周期性的一个东西。然后还有的话，就是那对于这个啊，就是我觉得还是不能用must的或者should这种其实。这种好像是对于人的要求，对于对于做这个事情的人的要求，但不是对于意图的描述，然后对意图的描述的话，其实可能更更适合用，比如说，啊，就是前面说的这种any how，然后还有比如说，就是其实指定的是代价，就是在这个指定的是，想要这个目标的情况下，愿意付出的代价是什么？Anyhow，比如说是a best effort，然后然后比如说是嗯，have a try。就是just just try然后，嗯还有一些是比如说，啊，还有一些是比如说衣服，诶。呃，衣服啊。嗯，就是如果有资源或者有如果有时间再去再去看的，比如说就是on leisure or somewhat。对，就这种对程度的表达。就对于这种，就是程度的就是这种意意图的意，意图的表达是依赖于这个，依赖于就是是应该从这个，嗯，从愿意付出的代价层面去描述意图
然后整个系统呢，啊，整个系统其实就是嗯最核心的还是去那个呃负上去做这个负熵增，就是推断他用户当前的意图其实还是一个呃负熵增的一个过程。就是根据就是有些比如有些intent，其实那个过了一段时间，比如完成之后或者过了某个时间之后，其实就已经无效了，然后这种结构就排除在外，然后对于这种所有有效的intent，我们所有涉及到的他所有的有效的intent要做，然后就通过这所有所有的的去啊，就那个就是总结出来他，去总结出来他现在想要的是什么。他现在想要的是什么？就他当前的这个，因为当前的这个intent是能够我去，当前的这个就是他当前的需需要去做什么，然后当前想要的是什么，然后根据这个是指导任务，指导这个下一步的工作的，我知道下一步要做什么的。对，指导下一步做什么？所以可能稍微有点不一样的想法是，他当前的意图其实不是就是意图这个是活的，就是当前的。他就他当前的意图，只能说是从历史意图里面去推断一下他当前当前的意图是什么，然后然后根据这个意图去就是其实当前的意图可能就是要做的一件事儿了。就是总结出来啊，就总结出他所有的意图，然后那我们可能给他三个选择，你就是你当前是想干这个，想干这个还是想干那个，然后把他这个所有的这种呃约束条件什么都带上，就是他比如说有一些有一些如果是always的这种呃，其实就是作为要去呃根据这个当前的意图去做事的时候的一种约束，就是把所有的意图叠加，然后变成一个当前需要当前的就是当前去做，然后去做了之后，其实从开发的角度来说，也是一个负上增的过程吧。也是一个负上增的过程。对，然后就是按照找出一个任务，然后做了之后整个系统就变得呃最清晰。就是是不是也可以这样去理解？

对于我当前的这个想法请帮我分析一下那里是好的，哪里是不好的


嗯，但是在就是在开发过程中，我觉得还有两种，就在一个项目项目里面，可能还有两种类型的数据，一种是，呃，一种是可以叫decision吧。就决策的数据。决策跟决策和这个意图是否是可以统一的呢？决策和意图是否可以统一呢？决策？决策我觉得就是在某一个问题上做了一个什么样的一个决定？其实某种程度上，某种程度上其实也也可以说是意图，就是决策就代表了意图，是一回事儿，就是呃比如说我决定比如说在代码里啊，在代码里不允许使用circle，必须使用orm。然后那这是一种决策，但实际上就变成了一种意图，实际上就是一种意图了。但是有些时候这个决策，呃是有一个嗯，对，其实就像你前面说的那个有一个是有一个背景的，或者说它有一个产生的过程，然后这个过程有可能是有用的。或者说在在什么背景下做了这个决策，然后当这个背景失效之后，这个决策实际上可能就动摇了。对，这是一个点，就是决策是什么样的一个？决策是什么样的一个定位？还有一些比如说呃就是还有一些比如说就是，还有一种就叫延迟决策嘛，延迟决策就是这个项目里有一个问题，然后然后这个呢？或者有有明知道有这么一个问题，但是现在没有精力做决策，然后其实就变成了一个延迟决策，然后延迟决策这种事情呢。如何放到意图里面，就是也是当然也可以硬放进去，比如说就是这个意图想要的结果就是什么时间，然后把这个把这个决策给做了有这样的一个决策。这个然后产生的决策，其其实又变成了意图的一种，啊，也可以从这个角度去去理解。去去定位。但不知道有没有更好的处理方式，对，这是决策。然后还有一种我觉得是芝士，或者说芝士裤。就是知识库和意图的这种区别是什么呢？知识库，对。然后知识库的话。他会这也是项目中的一种非常重要的信息吧。然后知识库是嗯，比如说有什么重要的知识，项目里面有哪些重要的知识库呢？比如说嗯当然这个知识知识库的话可以是作为repo的一部分，但是不知道对于决策是不是有影响，就是不是对于这个intent的这个推断是否是是否是有影响的，我觉得这也是影响，有可能是影响intent的推断的一个因素，要考要考虑的因素。关于这方面，呃，从信息工程产品这些角度来看，有什么样的分析和补充的看法？


嗯，那在时间维度觉得都都有哪些标签？都有哪些标签呢？就是用相对完备的来表描述，比如我想到的是首先有always这就是对于这种，啊，规则性的这种要求的这种时间的标签，还有像这个就代表就当下，啊，用户想要去实现的任务的这种时间标签。就是right now想还有像那个啊，比如说ultimateUltimate这个代表这个呃不知道是否最终是否准确啊，这个代表最终就是这个项目最终想要的。嗯，还有这种。嗯，还有还有什么


假设我们就从contest time cost和what这四个维度来定义intention。然后time这个维度下面有always right now ultimate。EverydayEvery week.Asap和someday。然后cost这个维度下面有anyhow。Best effortBalance的嗯，还和have a short。对，然后假设就是我们按这个来定义，然后下面我会描述一下啊，我的另一个那个另一个项目的另一个那个就是手机上来远程指导电脑开发的这个项目的一些想法，然后请你来帮我把我下面的这个所有的这些描述拆解成一条一条的intention，用上面的这个用上面的这个法则按这个这个形式，然后目标是做这个事情的目标是为了验证上面的这个呃形式的这个可用性和和这个包容性是否能够就是解决这一个实际的问题，能把所有的描述都很好的包容进来，按照这个形式嗯，下面我开始描述。然后我是想做这样一个事情，就是因为，就是因为就是当前大家首先1.1个背景是当前嗯就是AI现在能力越来越强，然后其实大家对于和工作的这个交界面会逐渐的转变。就是变成自然语言这种形式的交界面，而不是像以前我要使用专业的工具，比如要修图片，要那个编辑图片，然后以前呢可能要啊使用这个Photoshop，然后再按照Photoshop上面的这个指令这个各种工具去去用去点，然后先现在呢可能就说一下把把把我的脸给p瘦一点啊之类的，或者把这个背景给去掉之类的，然后就可以了，所以就变就形成了这样一种呃就这种模式的转变，大家就其实只需逐渐可能就需要用，只需要用自然语言去处理工作。然后呢？有用自然语言去处理工作之后，实际上会发生，我觉得会发生另一种转变，就是另一种形态的转变，就是大家不需要用电脑了，因为自然与使用Photoshop这种工具是需要用电脑的，因为不用电脑不行，因为对吧这个原因就不用讲了，但是我是自然语言的话，其实是不需要用电脑的。直接在手机上就可以输入，而手机上也可以打字，也可以用语音输入。这样就可以了。那如果大家不用电脑办公了，其实就会大家对大家来说是一个解放。因为大家就可以不用坐在办公桌前面了，对吧？你也可以在任何地方处理工作的事情，可以在景区，可以在沙滩边。对吧，然后所以这是一个背景，就是我推断出了我遇我我觉得可能会出现的一种形式，所以我要做下面的我这个产品，就是嗯在用手机来操纵电脑上的一些呃工具，一些软件。嗯，这是这里面还有另外一个考虑，就是现在大家其实还是主要就是未来是可能是那样的，但是现在大家普遍还都是在电脑上去工作的，就是大家的这个所有的工作的内容都在电脑上面然后呢？然后呢，那怎么样去衔接这个未来的趋势呢？我觉得就可以把能现在先能在手机上做的事情，就给搬到手机上。然后可能要做一个衔接，比如说现在的这个很多代码开发的工具，它虽然是基本上就输入这个自然语言就可以可以了，但是它其实代码都还是在电脑上，然后它的运行环境也是在电脑上，那啊我就做一个工具来把它这个把它的这个运行环境，它它运它的运行环境还是在电脑上面，但是呢我建一个网络的隧道，然后让它能够在手机上给这个呃编程的agent发指令比如说要写一个什么样的功能，然后对吧，然后这个一阵子就可以自己写了，然后写完之后把这个消息告诉他，我这个写完了，然后他在手机上就可以看到这个消息了，然后就可以在呃发进一步的指令。所以我整个要做的事情，一个是要建一个做一个好用的一个手机端的一个APP，然后暂时呢就先用就是第第一阶段先用这个pwa的这种方案。这是为了快速的先把这个东西，有一个东西做出来，做出来能用。然后前段写的就是后面是要做APP的，然后在安卓iOS上，因为这个易用性非常重要，啊pwa的易用性可能还是没那么好，没那么好，而且大家也就是大家都习惯于去应用市场上找应用，然后呃p的这种宣传也会有问题，然后第二点另外一点的话是就是要就是有了这个前端应用之后，然后我会以后有一个后端的服务来做这种消息的转发，其实就是做了一个消息的转发，然后在客户的电脑上，我就是会呃提供一个呃工具，就是对每一种他要转接到我的这个平台上的这个工具比如说对于cloud code和这种编程工具都会提供一个转接转接的一个转接的一个命令行工具。可能他在打开打开这个他的cloud code，然后再打开。再打开我的这个命令行工具，然后它的这个呃就可以在手机上操作它的这个cloud code了。然后呢，其实整个的架构也非常简单，就是通过通过这个web socket通信，就是我的这个命命令行工具会连接我后端的这个web socket然后然后我在这个前端呢，也是通过web socket跟后端去通信。然后他上线之后前端就是说的就是他这个连接到服务器上之后，我的他在前端就会收到他上线的消息，就他的agent上线的消息，然后他就可以给这个发消息了，然后然后经过后端转发到他的我的这个命令行工具上的之后，然后就会这名称工具会把这个输入通过，啊，比如说通过现在是通过这个tmux的这个方式，通过模拟输入，然后输入到它的这个对话框里面。对，整个流程就是这样的，就是这样一个产品。对，然后请把我上面描述的这个关于这个产品的一些这些东西看能否拆解成意图，然后有些看哪些能拆解，哪些不能拆解，就是按照上面的这种这种思维的模式。这种四个维度的这种intention的描述的这种框架


啊，所以这里面我发现了一个问题是呃，就是最开始我对这个context定义context的定义是其实是就是这个intention是在什么背景下才会激活？然后是这样的一个定义，但是在你给我的这个插解里面，其实这个context其实变成了，啊，产生这一个intention的背景。那能否再做这样的一件事情，就是还是对于我上面的这个输入。假设我们现在再加一个字段。因为context这个呃嗯Context这个呢有点确实有点混淆，然后我们呃就把这个字段换一下。字段换一下，然后加一个background加一个background，然后这个background用来代表就是这个intention产生的这个背景。产生的背景或者说他的呃，呃，来龙去脉或者就是为什么会有他这样的一个东西，然后context这个呃，如果容易混淆的话，我们就把它换掉，就变成就变成那个就变成很就变成那个on what。对，变成on what？就是意思是，啊什么的什么条件下会生效，就是这个隐态是是有什么样的这个条件约束。嗯，比如说在poc阶段，这个这个其实是条件，然后poc阶段我要用这个呃pwa，其实类似这样就是过了p poc阶段其实就没有这个呃用pa这个隐身了。就过了poc阶段就就不想用pwa了，其实这个就所以这这是这种是一个典型的条件的


然后我现在有一个想法就有一个把所有的东西都顺起来的一个思路是就是有四个维度的信息，就是有四个有有四个东西吧，啊，一个是一个是这个。Intention然后一个是这个。一个是这个decision。然后还有一个是这个。Knowledge然后然后还有一个是这个，就是project。然后他们四个的关系是这样。就是首先，这个IntentionIntension去就是有了这个意念之后。然后去改变project，然后然后改变了project之后呢，然后这个project他的这个信息，他的这个knowledge。然后就跟着变了。然后knowledge变了之后呢？就是因为那里这是decision的一个原谅，对吧？哪里只是的原原谅Knowledge是decision的原料。然后这个原料变了之后呢。然后就有新的decision当然这个原料，这里面这个knowledge不是desire的全部的驱动力。因为这部分这个discern的有很大一部分还是有这个人的，这个就是用户作者他的意志在里面，可能这个knowledge只是他去考虑的情况时候的一个一个参政，对，然后就形成了这样的一个循环，就是intention驱动这个project去更新，然后project的更新，然后就导致这个knowledge的更新，其实这个这从project到knowledge的更新是一个只是一个抽取或者是一个summary，其实这里面是一个相对确定性的。但是这个抽血必须要做，因为不做的话，呃就是没这个信息分散在这个project里面，分散在这个repro里面，这个是没法用的。就必须要有一个好的抽取的一个机制，但我觉得这个可能够不上够不成难点，现在这个应该能做的比较好。然后从knowledge到decision，就说这个knowledge只是decision的一个一部分，原料。然后有些原料可能来自于外部，来自于这个用户的认知，就是目前是不全是这个，有这个项目的，他的knowledge所决定的。然后然后得c任的结果，得c任的结果其实就成了intention。成了引开始成了意图，就这样的一个这样的一个迭代，然后这这里面为什么要把decision抽取出来，其实是这样，就是就是这个，光有intention的话，关于intention其实有点单薄，然后一个项目可能呃其实一个项目或者一个一个决策系统，其实我们构建的可能就是一个决策系统，然后它最重要的可能是这个决策过程。我们不能只记录结果，其实这里面都得塞着呃。重要的是这个就是为什么要抽出抽取出decision呢？然后这个因为呃这个我们关心的是这个决策过程。这个决策过程就是用户是基于什么样的情况下做了这样的一个决策，然后就是在后续的决决策中，这个决策过程是呃非常有这个参照价值的。非常有参照价值。然后请你从各个层面包括信息信息论，包括这个认知理论，包括产品理论，然后包括软件工程理论来分析一下和分析和补充一下，我就是整个刚才这一段的想法


关于决策这一块，关于decision这一块啊，就是首先它是一种数据，就是在在这个系统里的一种数据类型，然后我想到了这个数据的这个一些关于它的内涵和它的形态，一些方面的一些思考，请帮我从信息论或者就是各个层面，给我一些呃分析和扩展。首先关于decision的话，就这个decision数据，它呃要有决策过程，就是这是很重要的就每一个得是要，就每一个得是要要记录去记录明确的决策过程。对，这是一点，然后然后得确认的话有几种状态，有就每条每个数据的话，每条数据可能有一个状态，然后一共有这么几种，我现在想到的一个是tbd。然后还有一个是还有一个是outdated，还有一个是还有一个是valid的。对，valid的这种，然后还有一种是need review。就是tpd这种呢，就是一种呃用户现在有一个想法，就是他有一个带带带决策的事项，就现在没想清楚的。对，现在没有想没想清楚的，然后或者也没有结论，然后这里面甚至，比如说我们可以有一个架构助手，或者是一个一个参谋助手。然后跟他去讨论，跟他去讨论，然后讨论之后呢，可能有结论，可能没有结论，然后然后这个如果还还没有结论，然后这里面这个可能就记录一下这个讨论的过程之类的。对，然后用户也可以就是说一个他呃就是记录，其实这个就是帮他辅助他角色的，就是辅助他角色。比如说他有一个想法，我们先帮他记录下来，然后就还没有形成决策，这种就是tbd，然后还有那种已经已经过时的这种决策就是比如说他短期决策，就是要让做一个什么任务啊？这种，其实也是也是决策。然后但是这个显然这个做完之后，这个就已经过时了，就就其实就已经不用，基本上可以忽略了。当然他的这个决策过程，就是他的结果已经可以忽略了，但是他的这个决策过程，呃，是有参考价值的，是有价值的。然后还有这种还有这种valid的。然后这个就代表是一个正常的生效的一个决策。然后还有一种是就是需要重新REVIEW的。然后这个可能就是我们给他加上的一个标签，这个决策其实还是生效的，然后但是我们就是就是我们给他辅助决策的一点就是可能提醒他这个决策当时的就是决策决策过程中所记录的这种条件和这个现在已经变了，就是而且已经嗯就是不符合当时的条件了，甚至说已经相冲突了，那这时候就提醒他这个决策可能需要重新评估。对，这是关于决策这一块我的一些思考，然后请帮我呃请给我一些建议意见



然后还有一点是可能需要考虑的一点是就是有一些有一些状态是有一个有一些决策可能是他是比如说我们尝试过之后发现效果不好，试过之后发现效果不好。发现走不通，或者发现有问题，然后其实这种决策这种决策呢肯定就要就是在后续再做新的考虑的时候，就不能再考虑这条路了。或者不能在同样同等条件下再去考虑这条路了。然后就是这个状态怎么来维护，有什么样好的建议？这可能比如说引入一种新的角色的状态，就是已经呃废弃的。叫abandoned。而类似这样的一个东西，啊，还是说但是这个废气，这个废气这个状态怎么来维护是一个问题，就是这个可能。只能是手动来维护。还是说，还是说这个，就比如说这种决策，这种因为这个必须得有一个地方来记录嘛。这个必须得有一个地方来记录，因为项目里面可能记录的只是一个尝试失败了之后，然后整个的痕迹就抹去了，就找不到了，但是这个失败的这次失败的尝试要放在哪里呢？就是要么就是每个决策要关联一个结果，就是呃，看他这个现在这个决策导致的结果是怎么样的，那这种结果的评估。这种结果的评估。这种结果的评估当然是可以自动自动化的，是有些是显而易见的。我们如果去自动化这个过程的话，也是有价值的，倒也，但是这个怎么做来怎么做更好呢？


哎，你提醒的这我这一点非常好，就是提到的一点非常好，就是把这个失败的决策转成知识。嗯就这个是有可能能自动化的，对吧？失败的决策，然后因为决策可能失败的决策，往往都是这种就是尝试性的，就是试一下什么方向，然后然后呢这个然后这个方向呢，可能走着走着发现走不通，然后这个然后这时候再在这个抽取知识的时候，要把要把这个做了，做过哪些失败的尝试，不只是现状，要把历史上嗯，就做过哪些失败的尝试也也给他抽取出来，但是这样的话但有时候条件是不具备的


因为我希望整个系统的逻辑是非常简单，不想太复杂了，因为太复杂的，太复杂的往往是实现不了的，就是往往是实实现不了的，简单而且有效，是我所追求的，就是希望每个链条都是非常健壮的，不能依赖一些嗯，就是不能依赖一些成功性很低或者不太容易去实现的操作，来串通整个链条。这是我所考虑的


我想把intention改成是代表当前的想法的一种。一个词。就是因为decision其实代表的是整个角色的历史，然后隐身这块真正想要做的其实是从决策历史中去抽取出用户，当前的想法是什么？就是有什么合适的词来代表这个当前的想法这个概念吗？


那么其实意图很多，意图基本就等同于任务了，这个有点或者有些意图可能是比较大的任务，就需要去拆解他的意图，然后变成一些小的任务。那其实从意图到去影响这个项目的逻辑，可能就是这样，就是把意图拆解成任务，或者把意图转化为任务，然后把任务去落实


那么从这个decision到intension这个过程似乎非常简单，就就把这个有效的decision给抽取出来，抽取过来就是呃当前的intension了，似乎就只有这么一个过程。这里面有什么能想到什么更复杂的点吗？


那这个系统也可以从这个角度去理解，就是只有两种数据，一个是project，也就是repo，然后另一个是这个decision的数据然后像那个knowledge其实是project的衍生，我们并没有真正的knowledge的数据。然后这个decision呢是，然后这个intention呢是decision的衍生。所以他其实就变成了两种数据。然后user呢可以去操作project然后也可以去操作decision。就是用户可以还是作为一个开发者，他直接去开发，然后也可以从decision这边去入手，然后通过decision来驱动开发


这个项目我想最终的呈现，想给用户一种入手上手极为简单。就就是极为简单的，不用呃跟他不需要太多的认知负担，就能够快速上手，并且能够体验到核心功能。呃，但是呢，就后续他可以有有有很多东西，如果他愿意去熟悉我们的系统，他有一些东西可以自己去挖掘，就是啊，入门的一定要简单，然后后续的有一些比较有一定那个是给他一定的认知负担也没问题，就是要。是这样的，就是这个对于产品来说，对产产品呈现来说，我是有这样的一个约束


这个项目最重要的一点是对于生命周期的管理，我觉得。对于那个决策生命周期的管理。就是这个决策的生命周期，比如说因为决策的产生决策的过程，可能我设想是类似这样，比如用户主动发起他告诉我这个系统，给这个系统输入一个想法。然后呢，如果他的这个想法里面已经有有明显的这种决策意图。那可能就给他，我们就给他生成一个决策，把他的想法里面决策的部分抽取出来。然后呢？如果他的想法里面，就是可能还没有这种显著的决策的呃想法，显著的决策的明显的决策，那可能只是就做一个讨论，做一个讨论，然后然后呢这个就这个，然后现在那这个讨论呢，其实就是一个我这用户他的这个想法就是一个tbd的状态。然后就可以再进一步的去讨论，完善。然后最后收敛到一个决策。收敛出来一个角色，然后那这个角色这时候这个角色就是v类的的valid的状态。您这个那问题是什么时候这个决策？那什么时候这个决策变成就这个状态还好说，因为这个是创建的时候直接就赋予的。然后那问题是什么时候，比如说这个这决策的内容已经实现了，就是通过intention啊，通过通过就是intention通过这个呃写代码，这个已经对决策已经在项目项目里面已经实现了，那这时这个决策可能就是一个Fulfilled的状态。或者说completed，或者说嗯那这样就但是这个状态就是问题，还是这个。生命周期中的这个最后的这个状态的赋予是如何来进行的？一个潜在的想法是就是决策会被呃抽取成intention，然后intention会被转化为task，然后这些task会去写代码实现，然后最后合并到这个project里面，就是在最后这个合并的这个过程中，加一个呃，就是合并task的时候，然后如果就是他关联的这个decision都已经呃，他的所有的task都已经完成了，那这个decision这个decision就已经实现了。或者说，或者说不用这么麻烦，就是有一个通过通过这个。就是对每一个decision，有些每个这种还没有valid的decision，然后定期的去检查他的他的这个状态或者至少说这个，对，至少说这个那个task。对，是我觉得应该这样，就是这个decision通过，然后抽取出这个intention，然后再创建task，这个过程是非常可控的，这个关联性非常的可靠，然后那么只要这个只要这个task，只要这个task那个已经分配了。这个task已经分配了，然后这这时候就记录就给这个decision一个状态就是asend就是或者是已经就是安排下去了。然后等这个其实这样的时候就可以了，因为呃在那个在抽血，新的在抽血的时候，这样就不会那个影响，就对他就没有影响了，就不会认为这个decision还是要去实现就对，这样就就就就就有有一定的效果了，但是最后怎么变成fulfilled，这个还需要说，就是这个task都完成之后。嗯，对，然后等这个task都完成了，然后这个就自动变成feel feel的


对，你说的对，文件系统是最棒的。对，可以用一个目录将决策的元数据和每个决策分开，就是每个决策用一个文件，然后元数据的话放在一个统一的文件里面，比较方便去刻意做一个sdk去修改，这样可能好一点


在产品形态上就是呃我在想用户从用户到这个到这个decision data，然后这个过程中decision dateDecision data这个过程中，啊，我我我想了一个产品形态上的一个方案是其实就像就像这个AI聊天工具一样，它可以创建一个topic或者一个session。我没太想好他应该叫什么，就创建这一个之后，然后他就可以说他的想法，然后这个筛选也不用有名称。那当然他他也可以给他名称，但是不是必须的，他就可以在这个里面说他的想法，然后然后呢他就然后里面如果出现这种出现这种跟决策相关的。跟得跟角色相关的。然后呢这时候就通过AI自动识别，然后跟他确认是否要建创建这么一个决策。这是一种方式。嗯，然后对，然后也就有一些没有创建就是有一些那个没有明确的结论的，然后这时候也要创建一个决策，就是就是代表用户在考虑这个问题，然后呢，但是现在还没有结论，然后把他现在都考虑了哪些就是，记录下来。啊，这也是一种决策。就从这个他的用户给的这个输入里面去挖掘决策，然后这样用户就像使用聊天工具一样使用这个AI聊天工具一样就就可以完成这个角色的创建。对然后那这个就他每每创建这么一个session或者topic，这个具体叫什么更好呢？其实从我的想法来看，用户他每创建一个，嗯，他也可以把所有的都在同一个这个赛事里面去讨论，但是他如果是创建了多个的话，就说明每一个每创建一个都是有它的一个意图在的。就他想通过这个三人制讨论什么？然后未来，然后未来来说的话，就是我考虑比如说他真的做成像是一个聊天。呃，像是一个聊天工具，就可能他跟用户说了一句话，然后这时候呢就就就就是通过这个。嗯，就是这个decision的分析的这个工具，然后就提醒他啊是否要创建呃这个决策或者说18年创建什么这个决策，然后决策ID是什么什么什么，然后还可以在这个绘画里面添加这种，添加这种讨论的功能，就是让AI去给他有有哪些呃有哪些想法？就是比如AI可以帮他去分析代码，去分析这个查阅这个project，然后去嗯帮他给他一些决策信息，或者因为AI有大量的这种呃就是模型里内置的知识，然后也可以用它内置的知识去帮用户解答一些疑问，就帮他来辅助他的决策，这也是一个嗯，对，这也是一个，然后对，就变成一个聊天的，然后聊天的对话框，然后那这个每一个session叫什么名字比较



那这种thread每个thread的这种文件在，嗯，项目里面如何去存储？有什么好的建议吗？是每个thread存一个文件吗？就不断的往后append，这样去写。还是每条消息一个文件，这样这样的话会不会太多？


举一个例子，比如说现在我说我要做一个产品，然后比如说我要做一个聊天工具，就这么一句话，这种状态下他的熵是什么样的？

然后如果我经过一些描述说这个产品就是像微信一样，可以嗯可能像微信一样。另一个想法可能会像飞书一样，到这种状态下，他的熵是什么样的？

然后到最后我说因为什么样的理由，把这个聊天工具的所有细节都确定了下来，这时候的这个熵又是什么样的？


我们好像犯了一个错误， 当用户丢出来一个新的想法，这时的熵是高是低？ 如果这个想法经过扩展，想了好多种可能，但是没有结论，这时熵是更高了还是更低了，对于这个问题，其实熵是更低了才对； 能否从信息论的角度重新分析一下， 另外关于自由能是什么含义？


所以说，有些问题不一定非要讨论出非常明确的结论，有时候可能有两个结论，这时候就选一个去执行就好，因为如果这两个结论有冲突的话，我们在产生这两个结论的过程中已经向它们里面注入了大量的能量，如果不把这个结论落实，这些能量就释放不出来，对吧？而且还会消耗我们的自由能，造成我们的认知负担很重。这样理解对不对 ， 从科学批判的角度来评价


从科学跟信息学的角度来分析一下，减伤的过程是人的认知负担是一直增加，是一直增加的吗？还是说先增加然后后面又减小，然后这个认知负担的评价维度是什么样的？就是冲突的选择越多，就是同时存在的可能性越多，这个认知负担越重吗？


这里面提醒我的一点是，选择有时候并没有讨论清楚一个想法，可能最后做决定的时候并没有讨论清楚。就是，我们建议他先做一个选择，但是其他的决策过程要记录下来，然后其他的一些选项也要记录下来作为备选项。备选项也是后面因为这是花了很大力气，一起才走到这一步的，然后其他的选项其实也有很高的能量。


代码就是真正去实现这一步的时候，做实现的时候是不是也在做减熵？嗯，那有个问题，如果把一个很大的任务交给AI去执行，那它面临的挑战就比较高，有可能达不到预期。因为减伤代表着有很大的信息量，这些信息量应该在决策的时候就想清楚。大部分信息量应该在决策时累积起来，只把极小的信息量留在实现时去实现


然后我有个进一步的想法是，比如说拿那个做APP的例子来说，我想做一个社交APP，我提了这样一个想法，其实这本身就是一个决策，就代表我想做这么一个APP，但是这里面巨大的熵是巨大的，然后充满了大量无数的不确定性。

这时候整个系统要做的事情就是帮他减伤，然后累积能量，我觉得这个系统可以主动的帮他来减熵。就是说，你要做一个，做一个这个可能需要一些技巧，比如提出这种最有减商作用的问题让用户去回答，或者给一些选项让用户去选择。

通过这样，因为通过一些选择让用户去回答的话，这种决策负担是相对来说更低一点的。对，然后前面有了这么一个决策，后面就会引导他做出一些子决策，就是下一级的决策，然后可能还会有更下一级的决策，这样就形成了一个决策链。

直到每一个分支节点，他的熵已经足够低。然后这样的话，一旦上层的某个节点，比如用户上层的某一个节点，比如有多个分支，然后用户最后没有选这一个分支，然后其实这些就是其他分支上的它的子节点的决策就都直下了，就其实变成了一个认知上的图谱或者管理他们的一个依赖关系，就是这样的想法，我感觉听起来很美好，但是感觉就是他太严谨性的东西往往包容性就不够，而这个项目所面临的问题往往是极为复杂的，没有包容性的东西可能无法落实，请从软件工程、信息论、产品理论等方面来分析一下我这个想法的可行性，以及他的问题在什么地方？


